# L'upload d'image

Dans cet exemple, nous allons voir comment uploader une image pour l'avatar du user.

L'upload d'image dans une application NestJS peut √™tre r√©alis√© en utilisant le package `nestjs-form-data` pour g√©rer les formulaires multipart/form-data et `sharp` pour le traitement des images. Voici comment proc√©der.

_üîéNote: il existe diff√©rente mani√®re de g√©rer l'upload d'image notament via `Multer` mais personnelement, je trouve plus simple via cette mani√®re._

## Modofication du mod√®le User

Nous allons modifier le mod√®le `User` pour ajouter un champ pour l'avatar. Ce champ sera de type `string` pour stocker le chemin de l'image.

(fichier: `src\entities\user.entity.ts`)

```typescript
import { UserRole } from 'src/shared/enums/user-role.enum';
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity({ name: 'user' })
export class UserEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ length: 100, unique: true })
  username: string;

  @Column()
  password: string;

  @Column()
  firstname: string;

  @Column({ default: UserRole.Client })
  role: UserRole;

  // (NEW) Ajout du champ avatar
  @Column({ nullable: true })
  avatar: string; // url vers l'image de l'utilisateur (stock√©e sur le serveur)
}
```

Par d√©faut ce champ sera `null`, ce qui signifie que l'utilisateur n'a pas d'avatar.

## Installation des d√©pendances

Pour l'upload d'image, nous avons besoin de 2 packages:

- `nestjs-form-data` pour g√©rer les formulaires multipart/form-data
- `sharp` pour le traitement des images

```bash
npm install nestjs-form-data sharp
```

## Configuration du module

Dans le module principal (`app.module.ts`), nous devons importer le module `FormDataModule` de `nestjs-form-data` :

```typescript
import { MiddlewareConsumer, Module } from '@nestjs/common';
import { TodoController } from './controllers/todo.controller';
// (... autres imports)
import { NestjsFormDataModule } from 'nestjs-form-data'; // (NEW) 1. Importation du module

@Module({
  imports: [
    // import des .env
    ConfigModule.forRoot({ envFilePath: ['.env.dev', '.env'] }),
    // configuration pour le token JWT
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '1d' },
    }),
    // (... autres imports)
    NestjsFormDataModule, // (NEW) 2. Ajout du module dans les imports
  ],
  controllers: [TodoController, AuthController, UserController],
  providers: [TodoService, UserService],
})
export class AppModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(LoggingMiddleware).forRoutes('*');
    consumer.apply(AuthMiddleware).forRoutes('*');

    // '*' pour tous les routes, ou ['route1', 'route2']
  }
}
```

## Cr√©ation du DTO pour l'upload d'image

Nous allons cr√©er un DTO (Data Transfer Object) pour g√©rer l'upload d'image. Ce DTO contiendra le fichier image et √©ventuellement d'autres champs si n√©cessaire.

Pour l'exemple, nous allons cr√©er un DTO `UploadAvatarDto` qui contiendra le fichier image √† uploader.

(fichier: `src\dtos\user.form.dto.ts`)

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { HasMimeType, IsFile, MaxFileSize, MemoryStoredFile } from 'nestjs-form-data';

export class UploadAvatarDto {
  @ApiProperty({
    description: 'The avatar image file to upload',
    required: true,
    type: 'string',
    format: 'binary',
  })
  @IsFile()
  @MaxFileSize(5 * 1024 * 1024) // 5 MB
  @HasMimeType(['image/jpeg', 'image/png', 'image/gif'])
  image: MemoryStoredFile;
}
```

Explication:

- `@IsFile()`: Indique que le champ est un fichier.
- `@MaxFileSize(5 * 1024 * 1024)`: Limite la taille du fichier √† 5 Mo.
- `@HasMimeType(['image/jpeg', 'image/png', 'image/gif'])`: Limite les types MIME accept√©s aux images JPEG, PNG et GIF.
- `MemoryStoredFile`: Utilis√© pour stocker le fichier en m√©moire.

‚ö†Ô∏è Note: Vous pouvez ajuster les types MIME et la taille maximale selon vos besoins.
‚ö†Ô∏è Note2: Attention que le fichier est stock√© en m√©moire, donc si vous avez des fichiers volumineux, cela peut causer des probl√®mes de performance. Pour des fichiers plus volumineux, envisagez de les stocker sur le disque ou dans un service de stockage externe comme AWS S3.

## Cr√©ation du contr√¥leur pour l'upload d'image

Nous allons cr√©er un contr√¥leur pour g√©rer l'upload de l'avatar. Ce contr√¥leur contiendra une m√©thode pour uploader l'image et mettre √† jour le profil de l'utilisateur.

(fichier: `src\controllers\user.controller.ts` - `nest g controller controllers/user`)

```typescript
import { Body, Controller, Patch, Req, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiConsumes } from '@nestjs/swagger';
import { FormDataRequest } from 'nestjs-form-data';
import { UploadAvatarDto } from 'src/dtos/user.form.dto';
import { ConnectedGuard } from 'src/guards/connected.guard';
import { UserService } from 'src/services/user.service';
import { Session } from 'src/shared/interfaces/session.interface';

@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Patch('avatar')
  @ApiConsumes('multipart/form-data')
  @ApiBearerAuth()
  @UseGuards(ConnectedGuard)
  @FormDataRequest()
  async updateAvatar(
    @Req() req: Request & { session: Session },
    @Body() updateAvatarDto: UploadAvatarDto,
  ) {
    await this.userService.updateAvatar(req.session.id, updateAvatarDto.image); // la m√©thode updateAvatar doit √™tre impl√©ment√©e dans le service UserService
  }
}
```

Explication:

- `@Patch('avatar')`: D√©finit la route pour l'upload de l'avatar.
- `@ApiConsumes('multipart/form-data')`: Indique √† **Swagger** que cette route consomme des donn√©es de type `multipart/form-data`.
- `@FormDataRequest()`: Indique que cette m√©thode g√®re les requ√™tes de type `multipart/form-data`.
- `@UseGuards(ConnectedGuard)`: Prot√®ge la route avec le garde `ConnectedGuard` pour s'assurer que l'utilisateur est connect√©.
- `@Req() req: Request & { session: Session }`: R√©cup√®re la requ√™te et la session de l'utilisateur connect√©. (pour acc√®der √† l'ID de l'utilisateur)
- `@Body() updateAvatarDto: UploadAvatarDto`: R√©cup√®re les donn√©es du formulaire, y compris le fichier image.
- `await this.userService.updateAvatar(req.session.id, updateAvatarDto.image)`: Appelle la m√©thode `updateAvatar` du service `UserService` pour mettre √† jour l'avatar de l'utilisateur.

## Impl√©mentation de la m√©thode `updateAvatar` dans le service UserService

(fichier: `src\services\user.service.ts`)

```typescript
import { Injectable } from '@nestjs/common';
// (... autres imports)

// Nouveaux imports utiliser pour l'upload d'image
import * as sharp from 'sharp';
import { MemoryStoredFile } from 'nestjs-form-data';
import * as fs from 'fs';
import * as path from 'path';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(UserEntity)
    private readonly userRepository: Repository<UserEntity>,
  ) {}

  // (... autre m√©thodes)

  // NEW
  async updateAvatar(userId: string, avatarFile: MemoryStoredFile): Promise<boolean> {
    const user = await this.userRepository.findOne({ where: { id: userId } });
    if (!user) {
      throw new Error('User not found');
    }

    // Converssion de l'image en format WebP et redimensionnement (par exemple, 200x200 pixels)
    const processedImage = await sharp(avatarFile.buffer)
      .resize(200, 200) // taille de l'image
      .webp({ quality: 50 }) // convertit en format WebP avec une qualit√© de 50%
      .toBuffer();

    // D√©finir le chemin o√π l'image sera enregistr√©e
    const filePath = `public/images/avatars/${userId}.webp`;
    const absolutePath = path.resolve(__dirname, '..', '..', filePath);

    // V√©rification et cr√©ation du r√©pertoire si n√©cessaire
    await fs.promises.mkdir(path.dirname(absolutePath), { recursive: true });

    // Enregistrer l'image trait√©e dans le syst√®me de fichiers
    await fs.promises.writeFile(absolutePath, processedImage);

    // Mettre √† jour l'URL de l'avatar dans la base de donn√©es
    user.avatar = filePath;
    await this.userRepository.save(user);

    return true;
  }
}
```

Explication des imports:

- `sharp`: Utilis√© pour traiter l'image (redimensionnement et conversion en format WebP).
- `MemoryStoredFile`: Repr√©sente le fichier image upload√©.
- `fs.promises`: Utilis√© pour √©crire le fichier sur le syst√®me de fichiers.
- `path`: Utilis√© pour g√©rer les chemins de fichiers.

Explication de la m√©thode `updateAvatar`:

- R√©cup√®re l'utilisateur √† partir de son ID.
- Traite l'image en la redimensionnant √† 200x200 pixels et en la convertissant en format WebP.
- D√©finit le chemin o√π l'image sera enregistr√©e.
- V√©rifie si le r√©pertoire existe et le cr√©e si n√©cessaire.
- Enregistre l'image trait√©e dans le syst√®me de fichiers.
- Met √† jour l'URL de l'avatar dans la base de donn√©es.

## Test de l'upload d'image

Dans Swagger, connectez-vous avec un utilisateur, puis acc√©dez √† la route `/user/avatar` et utilisez l'option pour uploader un fichier. S√©lectionnez une image et envoyez la requ√™te.

![upload-image-test.png](images/upload-image-test.png)

Si tout fonctionne correctement, l'image sera trait√©e, enregistr√©e sur le serveur (dans le dossier `public/images/avatars`) et l'URL de l'avatar sera mise √† jour dans la base de donn√©es.
