# DTO et la validation

Les DTOs (Data Transfer Objects) sont des objets utilisés pour transférer des données entre les couches de
l'application. Ils permettent de structurer les données envoyées et reçues par les contrôleurs, facilitant ainsi la
validation et la sérialisation.

Il existe deux types de DTOs :

- **DTO de sortie** : utilisé pour structurer les données renvoyées par les contrôleurs.
- **DTO d'entrée** : utilisé pour structurer les données reçues par les contrôleurs, souvent en combinaison avec des
  pipes de validation.

⚠️⚠️⚠️

Attention, les DTOs ne sont supposés être utilisés que pour le transfert de
données (cad dans les controlleurs) et ne doivent pas être utilisés pour la logique métier. Pour cela, nous utiliserons
des entités (Entities) qui seront utilisées dans les services.

Pour faire le passage entre les DTOs et les entités, nous créerons des mappers (des classes qui convertissent un DTO
en une entité et vice versa). Ces mappers seront utilisés dans les controleurs.

⚠️⚠️⚠️

## DTO de sortie

Créer un dossier `dtos` dans le dossier `src` et ajouter un fichier `todo.dto.ts` :

```typescript
export class TodoDto {
  id: number;
  title: string;
  description?: string;
  completed: boolean;
}
```

(sera utilisé pour structurer les données renvoyées par les contrôleurs, plus tard lorsque nous implémenterons la
connexion à la base de données)

## DTO d'entrée

Créer un fichier `todo.form.dto.ts` dans le dossier `dtos` :

```typescript
export class TodoCreateFormDto {
  title: string;
  description?: string;
  completed?: boolean;
}

export class TodoUpdateFormDto {
  title?: string;
  description?: string;
}

export class TodoCompletionDto {
  completed: boolean;
}
```

Ces DTOs seront utilisés pour structurer les données reçues par les contrôleurs, notamment lors de la création et de la
mise à jour des tâches.

## Validation des DTOs

Pour valider les DTOs d'entrée, nous allons utiliser la bibliothèque `class-validator`. Installez-la avec la commande

```bash
npm install class-validator class-transformer
```

- `class-validator` : fournit les décorateurs de validation (ex: @IsString(), @IsEmail(), @Length(), etc.)

- `class-transformer` : permet de transformer automatiquement le JSON reçu en instances de classes TypeScript (
  nécessaire pour que la validation fonctionne).

Ensuite, modifiez les DTOs d'entrée pour ajouter des décorateurs de validation :

```typescript
import { IsString, IsOptional, IsBoolean } from 'class-validator';

export class TodoCreateFormDto {
  @IsString()
  title: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsOptional()
  @IsBoolean()
  completed?: boolean;
}

export class TodoUpdateFormDto {
  @IsOptional()
  @IsString()
  title?: string;

  @IsOptional()
  @IsString()
  description?: string;
}

export class TodoCompletionDto {
  @IsBoolean()
  completed: boolean;
}
```

Ces décorateurs permettent de valider les données reçues par les contrôleurs. Par exemple, si le champ `title` n'est pas
une chaîne de caractères, une erreur de validation sera levée.

## Activation de la validation globale

Pour activer la validation globale dans NestJS, modifiez le fichier `main.ts` :

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.useGlobalPipes(new ValidationPipe());

  await app.listen(process.env.PORT ?? 3000);
}

bootstrap();
```

## Mise à jour des contrôleurs

Nous pouvons maintenant mettre à jour les contrôleurs pour utiliser les DTOs d'entrée et bénéficier de la validation.

(dans la route `create`, `update` et `toggleTodoCompletion`)

```typescript
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  ParseIntPipe,
  Patch,
  Post,
  Put,
} from '@nestjs/common';
import { TodoService } from '../services/todo.service';

@Controller('todo')
export class TodoController {
  constructor(private readonly todoService: TodoService) {}

  @Get()
  async getAll() {
    return this.todoService.getAll();
  }

  @Post()
  // On remplace "any" par le DTO TodoCreateFormDto
  async create(@Body() body: TodoCreateFormDto) {
    return this.todoService.create(body);
  }

  @Get(':id')
  async getById(@Param('id', ParseIntPipe) id: number) {
    return this.todoService.getById(id);
  }

  @Put(':id')
  // On remplace "any" par le DTO TodoUpdateFormDto
  async update(@Param('id', ParseIntPipe) id: number, @Body() body: TodoUpdateFormDto) {
    return this.todoService.update(id, body);
  }

  @Patch(':id/complete')
  // On remplace "any" par le DTO TodoCompletionDto
  async toggleTodoCompletion(
    @Param('id', ParseIntPipe) id: number,
    @Body() body: TodoCompletionDto,
  ) {
    return this.todoService.toggleTodoCompletion(id, body);
  }

  @Delete(':id')
  async delete(@Param('id', ParseIntPipe) id: number) {
    return this.todoService.delete(id);
  }
}
```
