# Gestion des erreurs (filters)

La gestion des erreurs dans NestJS est essentielle pour fournir une expérience utilisateur cohérente et informative. Les
filtres d'exception permettent de capturer les erreurs et de les formater avant de les renvoyer au client.

## Création d'exceptions personnalisées

Pour chaque erreur générée par l'application, il nous faut créer une exception personnalisée.

Pour cela, nous allons créer un dossier `shared/models` dans notre projet et y ajouter un fichier `errors.model.ts`.

Avec comme contenu :

```typescript
export class NotFoundException extends Error {
}

export class EmailAlreadyExistsException extends Error {
}

export class InvalidLoginException extends Error {
}
```

Cette approche nous permet de centraliser la gestion des erreurs et de les rendre facilement réutilisables dans
l'ensemble de l'application.

## Utilisation des exceptions personnalisées
Pour utiliser ces exceptions personnalisées, nous allons les importer dans nos contrôleurs ou services et les lancer lorsqu'une condition d'erreur est rencontrée.

Exemple dans un service avec la méthode `getById` :

```typescript
async getTodoById(id: number): Promise<Todo> {
    const todo = await this.todoRepository.findOne({ where: { id } });
    if (!todo) {
        throw new NotFoundException('Todo not found'); // remplacer "Error" par notre exception personnalisée "NotFoundException"
    }
    return todo;
}
```

## Création d'un filtre d'exception personnalisé (pour les codes d'erreurs http)

Pour créer un filtre d'exception personnalisé, nous devons créer un fichier `http-exception.filter.ts` dans le dossier
`filters` de notre projet. Ce filtre va intercepter les exceptions HTTP et les formater.

Commande de génération :

```bash
nest g filter filters/http-exception
```

Contenu du fichier `http-exception.filter.ts` :

```typescript
import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus } from '@nestjs/common';
import { Request, Response } from 'express';
import {
  EmailAlreadyExistsException,
  InvalidLoginException,
  NotFoundException,
} from '../shared/models/errors.model';

@Catch()
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response: Response = ctx.getResponse();
    const request: Request = ctx.getRequest();

    let status: HttpStatus = HttpStatus.INTERNAL_SERVER_ERROR;
    let message = 'Internal server error';

    if (exception instanceof NotFoundException) {
      status = HttpStatus.NOT_FOUND;
      message = exception.message || 'Resource not found';
    } else if (
      exception instanceof EmailAlreadyExistsException ||
      exception instanceof InvalidLoginException
    ) {
      status = HttpStatus.BAD_REQUEST;
      message = exception.message || 'Bad request';
    } else if (exception instanceof HttpException) {
      // Pour capturer proprement les exceptions Nest natives
      status = exception.getStatus();
      const res = exception.getResponse();
      message = typeof res === 'string' ? res : (res as Error).message || message;
    } else {
      // Pour les exceptions non gérées, on log l'erreur
      console.error('Unhandled error:', exception);
    }

    response.status(status).json({
      message,
    });
  }
}
```