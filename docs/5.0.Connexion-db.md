# Connexion à la base de données avec TypeORM

TypeORM est un ORM (Object-Relational Mapping) qui permet de gérer la connexion à la base de données et les entités de
manière efficace. Dans ce chapitre, nous allons configurer TypeORM pour se connecter à une base de données MSSQL et
définir les entités User et Todo.

## Installation de TypeORM et des dépendances

Pour commencer, nous devons installer TypeORM ainsi que le pilote MSSQL. Exécutez la commande suivante dans votre
projet NestJS :

```bash
npm install @nestjs/typeorm typeorm mssql
```

- `@nestjs/typeorm` : Le module TypeORM pour NestJS.
- `typeorm` : Le package principal de TypeORM.
- `mssql` : Le pilote pour se connecter à une base de données MSSQL.

## Configuration de TypeORM

Dans le fichier `app.module.ts`, nous allons configurer TypeORM pour se connecter à notre base de données MSSQL. Voici
un exemple de configuration :

```typescript
import { Module } from '@nestjs/common';
import { AppController } from './controllers/app.controller';
import { AppService } from './app.service';
import { TodoController } from './controllers/todo.controller';
import { TodoService } from './services/todo.service';
import { TypeOrmModule } from '@nestjs/typeorm';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'mssql',
      host: 'localhost',
      port: 1433,
      database: 'nestjs_todo',
      username: 'SA',
      password: 'Some4Complex#Password',
      options: {
        encrypt: true,
        trustServerCertificate: true, // Use true for local development
      },
      synchronize: true,
      logging: true,
      entities: [
        // TODO enregistrement des entités ici
      ],
    }),
    TypeOrmModule.forFeature([
      // TODO enregistrement des entités ici
    ]),
  ],
  controllers: [AppController, TodoController],
  providers: [AppService, TodoService],
})
export class AppModule {}
```

Dans cette configuration :

- `type` : Le type de base de données, ici `mssql`.
- `host` : L'adresse du serveur de base de données.
- `port` : Le port sur lequel le serveur de base de données écoute, par défaut 1433 pour MSSQL.
- `database` : Le nom de la base de données à laquelle se connecter.
- `username` et `password` : Les identifiants pour se connecter à la base de données.
- `options` : Options supplémentaires pour la connexion, comme `encrypt` pour les connexions sécurisées et
  `trustServerCertificate` pour les environnements de développement locaux.
- `synchronize` : Si `true`, TypeORM synchronisera automatiquement les entités avec la base de données à chaque
  démarrage de l'application. **Attention** : Ne pas utiliser en production, car cela peut entraîner la perte de
  données.
- `logging` : Si `true`, TypeORM affichera les requêtes SQL dans la console.
- `entities` : Liste des entités à enregistrer. Nous allons ajouter les entités `User` et `Todo` ici.
- `TypeOrmModule.forFeature` : Permet d'enregistrer les entités pour l'injection de dépendances dans les services.

## Définition des entités

### Entité Todo

Créons d'abord l'entité `Todo`. Créez un fichier `todo.entity.ts` dans le dossier `entities` :

```typescript
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class Todo {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ length: 100 })
  title: string;

  @Column({ type: 'text', nullable: true })
  description: string | null;

  @Column({ default: false })
  completed: boolean;
}
```

Expliquons les annotations utilisées :

- `@Entity()` : Indique que cette classe est une entité de base de données.
- `@PrimaryGeneratedColumn()` : Indique que cette colonne est une clé primaire générée automatiquement.
- `@Column()` : Indique une colonne de la table. Les options comme `length`, `type`, et `nullable` permettent de définir
  les propriétés de la colonne.
- `@Column({ default: false })` : Définit une valeur par défaut pour la colonne `completed`.
- `nullable: true` : Indique que la colonne peut être nulle.
- `type: 'text'` : Définit le type de la colonne comme texte, utile pour des descriptions longues.
- `length: 100` : Définit la longueur maximale de la colonne `title`.

## Ajout de l'entité Todo dans le module TypeORM

Ajoutons maintenant l'entité `Todo` dans le module TypeORM. Modifiez le fichier `app.module.ts` pour inclure l'entité
`Todo` :

```typescript
//(...)
imports: [
  TypeOrmModule.forRoot({
    type: 'mssql',
    host: 'localhost',
    port: 1433,
    database: 'nestjs_todo',
    username: 'SA',
    password: 'Some4Complex#Password',
    options: {
      encrypt: true,
      trustServerCertificate: true,
    },
    synchronize: true,
    logging: true,
    entities: [Todo], // Enregistrement de l'entité Todo
  }),
  TypeOrmModule.forFeature([Todo]), // Enregistrement de l'entité Todo
],
//(...)
```

## DTO to Entity

Les DTO (Data Transfer Object) sont utilisés pour définir la structure des données qui seront envoyées ou reçues par les
contrôleurs. Une fois l'étape de validation terminée par le contrôleur, les DTOs sont transformés en entités par des `Mappers`

Il faut donc maintenant écrire des `Mappers` pour transfomer les `DTOs form` en entités et les entités en `DTOs` qui sont retourné par l'API.

### `todo.dto.ts`

Dans le fichier `todo.dto.ts`, nous allons écrire la méthode de conversion de l'entité `Todo` en DTO. Voici un exemple :

```typescript

```

## Refactoring service Todo

Maintenant que nous avons défini l'entité `Todo`, nous allons implémenter le service `TodoService` pour gérer les
opérations CRUD sur les tâches. Voici un exemple de service :

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Todo } from '../entities/todo.entity';
import { TodoFormDto, TodoUpdateDto, TodoCompletionDto } from '../dtos/todo.form.dto';

@Injectable()
export class TodoService {
  constructor(
    @InjectRepository(Todo)
    private readonly todoRepository: Repository<Todo>,
  ) {}

  async getTodos(): Promise<Todo[]> {
    // On récupère tous les todos
    return this.todoRepository.find();
  }

  async createTodo(body: TodoFormDto): Promise<Todo> {
    // On crée un nouvel objet (sans l'enregistrer)
    const todo = this.todoRepository.create({
      title: body.title,
      description: body.description || null,
      completed: false,
    });
    // On enregistre le todo en DB
    return this.todoRepository.save(todo);
  }

  async getTodoById(id: number): Promise<Todo> {
    const todo = await this.todoRepository.findOne({ where: { id } });
    if (!todo) {
      throw new NotFoundException('Todo not found');
    }
    return todo;
  }

  async updateTodo(id: number, body: TodoUpdateDto): Promise<Todo> {
    const todo = await this.getTodoById(id);
    todo.title = body.title ?? todo.title;
    todo.description = body.description ?? todo.description;
    return this.todoRepository.save(todo);
  }

  async deleteTodo(id: number): Promise<Todo> {
    const todo = await this.getTodoById(id);
    await this.todoRepository.remove(todo);
    return todo;
  }

  async toggleTodoCompletion(id: number, body: TodoCompletionDto): Promise<Todo> {
    const todo = await this.getTodoById(id);
    todo.completed = body.completed !== undefined ? body.completed : !todo.completed;
    return this.todoRepository.save(todo);
  }
}
```

Dans ce service :

- `@InjectRepository(Todo)` : Injecte le repository de l'entité `Todo` pour effectuer des opérations CRUD.
- `getTodos()` : Récupère tous les todos de la base de données.
- `createTodo(body: TodoFormDto)` : Crée un nouveau todo à partir des données du formulaire et l'enregistre dans la base
  de données.
- `getTodoById(id: number)` : Récupère un todo par son ID, en lançant une exception si le todo n'existe pas.
- `updateTodo(id: number, body: TodoUpdateDto)` : Met à jour un todo existant avec les données fournies.
- `deleteTodo(id: number)` : Supprime un todo par son ID.
- `toggleTodoCompletion(id: number, body: TodoCompletionDto)` : Bascule l'état de complétion d'un todo.
- `todoRepository.create()` : Crée une instance de l'entité `Todo` sans l'enregistrer immédiatement.
- `todoRepository.save(todo)` : Enregistre l'entité `Todo` dans la base de données.
- `todoRepository.findOne({ where: { id } })` : Récupère un todo spécifique en utilisant une condition de recherche.
- `todoRepository.remove(todo)` : Supprime un todo de la base de données.
