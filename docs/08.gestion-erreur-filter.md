# Gestion des erreurs (filters)

La gestion des erreurs dans NestJS est essentielle pour fournir une exp√©rience utilisateur coh√©rente et informative. Les
filtres d'exception permettent de capturer les erreurs et de les formater avant de les renvoyer au client.

## Cr√©ation d'exceptions personnalis√©es

Pour chaque erreur g√©n√©r√©e par l'application (tout les `throw new Error` dans notre code), il nous faut cr√©er une exception personnalis√©e.

Pour cela, nous allons cr√©er un dossier `shared/models` dans notre projet et y ajouter un fichier `errors.model.ts`.

Avec comme contenu :

```typescript
export class UsernameAlreadyExistsException extends Error {
  constructor(username: string) {
    super(`Username ${username} already exists.`);
    this.name = 'UsernameAlreadyExistsException';
  }
}

export class InvalidLoginException extends Error {
  constructor() {
    super(`Invalid login`);
    this.name = 'InvalidLoginException';
  }
}

export class NotFoundException extends Error {
  constructor() {
    super(`Not found`);
    this.name = 'NotFoundException';
  }
}
```

Explications:

- `extends Error`: Nous √©tendons la classe native `Error` pour cr√©er nos exceptions personnalis√©es.
- `super(message)`: Nous appelons le constructeur de la classe `Error` avec un message sp√©cifique.
- `this.name`: Nous d√©finissons un nom sp√©cifique pour chaque exception, ce qui permet de

- `UsernameAlreadyExistsException`: Exception lev√©e lorsque l'utilisateur essaie de s'inscrire avec un nom d'utilisateur d√©j√† pris. (remplacera `throw new Error('Username already exists');`)
- `InvalidLoginException`: Exception lev√©e lorsque les informations de connexion sont invalides. (remplacera `throw new Error('Invalid login');`)
- `NotFoundException`: Exception lev√©e lorsque la ressource demand√©e n'est pas trouv√©e. (remplacera `throw new Error('??? not found');`)

Cette approche nous permet de centraliser la gestion des erreurs et de les rendre facilement r√©utilisables dans l'ensemble de l'application.

## Utilisation des exceptions personnalis√©es

Pour utiliser ces exceptions personnalis√©es, nous allons les importer dans nos contr√¥leurs ou services et les lancer lorsqu'une condition d'erreur est rencontr√©e.

Exemple dans un service avec la m√©thode `getById` :

```typescript
  async getById(id: number) {
    const todo = await this.todoRepository.findOne({ where: { id } });
    if (!todo) {
      throw new NotFoundException(); // remplacer "Error" par notre exception personnalis√©e "NotFoundException"
    }
    return todo;
  }
```

üîé √Ä vous de chercher tout les `throw new Error` et les remplacer par nos exceptions personnalis√©es.

## Cr√©ation d'un filtre d'exception personnalis√© (pour les codes d'erreurs http)

Un filtre en NestJS est une classe qui sert √† intercepter les exceptions lanc√©es dans l'application et √† les traiter de mani√®re centralis√©e. Cela permet de g√©rer les erreurs de mani√®re coh√©rente et de renvoyer des r√©ponses format√©es au client.

Pour cr√©er un filtre d'exception personnalis√©, nous devons cr√©er un fichier `http-exception.filter.ts` dans le dossier
`filters` de notre projet. Ce filtre va intercepter les exceptions HTTP et les formater.

Commande de g√©n√©ration :

```bash
nest g filter filters/http-exception
```

Contenu du fichier `http-exception.filter.ts` :

```typescript
import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus } from '@nestjs/common';
import { Response } from 'express';
import {
  InvalidLoginException,
  NotFoundException,
  UsernameAlreadyExistsException,
} from 'src/shared/models/errors.model';

@Catch()
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response: Response = ctx.getResponse();

    let status = HttpStatus.INTERNAL_SERVER_ERROR;
    let message = 'Internal server error';

    if (exception instanceof NotFoundException) {
      status = HttpStatus.NOT_FOUND;
      message = exception.message;
    } else if (
      exception instanceof UsernameAlreadyExistsException ||
      exception instanceof InvalidLoginException
    ) {
      status = HttpStatus.BAD_REQUEST;
      message = exception.message;
    } else if (exception instanceof HttpException) {
      status = exception.getStatus();
      const res = exception.getResponse();
      message = typeof res === 'string' ? res : (res as Error).message || message;
    } else {
      // SI ce console l'affiche, c'est que l'erreur n'est pas g√©r√©e par nos exceptions personnalis√©es et qu'il y a un probl√®me dans notre code. üöëüöëüöë
      console.error(exception);
      // TODO envoyer a Sentry (http://sentry.io/)
    }

    response.status(status).json({
      message,
    });
  }
}
```

Explications:

- `@Catch()`: D√©corateur qui indique que cette classe est un filtre d'exception. Il peut capturer toutes les exceptions.
- `catch(exception: unknown, host: ArgumentsHost)`: M√©thode qui sera appel√©e lorsqu'une exception est lanc√©e. Elle re√ßoit l'exception et le contexte d'ex√©cution.
- `host.switchToHttp()`: Permet de passer du contexte d'ex√©cution √† un contexte HTTP.
- `ctx.getResponse()`: R√©cup√®re la r√©ponse HTTP pour envoyer une r√©ponse format√©e au client.
- `HttpStatus`: Enum√©ration qui contient les codes de statut HTTP.
- `if (exception instanceof NotFoundException)`: V√©rifie si l'exception est une de nos exceptions personnalis√©es. Si c'est le cas, nous d√©finissons le statut et le message appropri√©s.
- `else if (exception instanceof HttpException)`: V√©rifie si l'exception est une exception HTTP standard de NestJS. Si c'est le cas, nous r√©cup√©rons le statut et le message de l'exception.
- `else`: Si l'exception n'est pas g√©r√©e par nos exceptions personnalis√©es, nous affichons l'erreur dans la console pour le d√©bogage. Cela peut indiquer un probl√®me dans notre code qui n'est pas g√©r√© par nos exceptions personnalis√©es.
- `response.status(status).json({ message })`: Envoie la r√©ponse au client avec le statut et le message format√©.

## Mise en place du filtre d'exception

Pour que le filtre d'exception soit utilis√© dans l'application, nous devons l'enregistrer dans le fichier principal `main.ts`.

Dans le fichier `main.ts`, ajoutez le filtre d'exception globalement :

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { HttpExceptionFilter } from './filters/http-exception.filter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Validation des DTOs
  app.useGlobalPipes(new ValidationPipe());

  // Gestion des erreurs
  app.useGlobalFilters(new HttpExceptionFilter()); // NEW

  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
```
