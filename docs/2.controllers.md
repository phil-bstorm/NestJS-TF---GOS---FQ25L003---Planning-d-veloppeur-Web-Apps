# Controllers

Les contrôleurs dans NestJS sont des classes qui gèrent les requêtes HTTP entrantes et renvoient des réponses. Ils sont
responsables de la logique de traitement des requêtes et de la communication avec les services.

## Création d'un contrôleur

Pour créer un contrôleur, vous pouvez utiliser la commande CLI de NestJS. Par exemple, pour créer un contrôleur
`todo`, vous pouvez exécuter la commande suivante :

```bash
nest generate controller controllers/todo
```

Cela créera un fichier `todo.controller.ts` dans le dossier `src/controllers/`.

Note: lorsque l'on crée un contrôleur, NestJS ajoute automatiquement le controlleur dans le module parent (ici
`app.module.ts`).

Fichier `todo.controller.ts` :

```typescript
import { Controller } from '@nestjs/common';

@Controller('todo')
export class TodoController {
}
```

Explication du code:

- `@Controller('todo')`: Le décorateur `@Controller` indique que cette classe est un contrôleur. Le paramètre `'todo'`
  spécifie le chemin de base pour toutes les routes définies dans ce contrôleur. Par exemple, si vous définissez une
  méthode avec le décorateur `@Get()`, elle sera accessible via `/todo`.
- `export class TodoController`: La classe `TodoController` est exportée pour être utilisée dans d'autres parties de l'
  application. Elle peut contenir des méthodes pour gérer les requêtes HTTP.

## Endpoints dans un contrôleur

### Get

Le premier endpoint que nous allons ajouter est un endpoint GET qui renvoie une liste de tâches. Pour cela, nous allons
utiliser le décorateur `@Get()` pour définir une méthode qui sera appelée lorsque le client enverra une requête GET à
l'URL `/todo`.

```typescript
import { Controller, Get } from '@nestjs/common';

@Controller('todo')
export class TodoController {
  todos = [
    { id: 1, title: 'Learn NestJS', completed: false },
    { id: 2, title: 'Build a REST API', completed: false },
    { id: 3, title: 'Deploy to production', completed: false },
  ];

  @Get()
  async getTodos() {
    await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate async operation

    return this.todos;
  }
}
```

Explication du code:

- `todos`: La propriété `todos` est un tableau d'objets représentant les tâches. Chaque objet a un `id`, un `title` et
  un `completed` pour indiquer si la tâche est terminée ou non.
- `@Get()`: Le décorateur `@Get()` indique que cette méthode sera appelée pour les requêtes HTTP GET à l'URL `/todo`.
- `async getTodos()`: La méthode `getTodos` est définie comme asynchrone, ce qui permet d'utiliser `await` à l'intérieur
  de la méthode. Dans cet exemple, nous simulons une opération asynchrone avec un délai de 1 seconde avant de renvoyer
  la liste des tâches.
- `await new Promise((resolve) => setTimeout(resolve, 1000))`: Cette ligne simule une opération asynchrone, comme une
  requête à une base de données ou un appel à un service externe. Dans un cas réel, vous remplaceriez cette ligne par
  une logique pour récupérer les données depuis une source de données.
- `return this.todos`: La méthode renvoie la liste des tâches définie dans la propriété `todos`. NestJS convertit
  automatiquement cette liste en JSON pour la réponse HTTP.

### Post

Pour ajouter un endpoint POST qui permet de créer une nouvelle tâche, nous allons utiliser le décorateur `@Post()`. Nous
allons également utiliser le décorateur `@Body()` pour extraire les données de la requête.

```typescript
import { Controller, Get, Post, Body } from '@nestjs/common';

//(...)

@Post()
async
createTodo(@Body()
body: any
)
{
  await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate async operation

  const newTodo = {
    id: this.todos.length + 1,
    title: body.title,
    completed: false,
  };
  this.todos.push(newTodo);
  return newTodo;
}
```

Explication du code:

- `@Post()`: Le décorateur `@Post()` indique que cette méthode sera appelée pour les requêtes HTTP POST à l'URL `/todo`.
- `async createTodo(@Body() body: any)`: La méthode `createTodo` est définie comme asynchrone et utilise le décorateur
  `@Body()` pour extraire les données de la requête. Le paramètre `body` contiendra les données envoyées dans le corps
  de la requête.
- `await new Promise((resolve) => setTimeout(resolve, 1000))`: Comme précédemment, cette ligne simule une opération
  asynchrone.
- `const newTodo = {...}`: Nous créons un nouvel objet `newTodo` avec un `id` unique, le `title` provenant du corps de
  la requête et `completed` initialisé à `false`.
- `this.todos.push(newTodo)`: Nous ajoutons le nouvel objet `newTodo` au tableau `todos`.
- `return newTodo`: La méthode renvoie le nouvel objet `newTodo`, qui sera converti en JSON pour la réponse HTTP.

### Get (avec paramètre)

Pour ajouter un endpoint GET qui permet de récupérer une tâche spécifique par son ID, nous allons utiliser le décorateur
`@Get(':id')`. Le paramètre `:id` dans l'URL indique que nous attendons un paramètre d'URL.

```typescript
import { Controller, Get, Post, Body, Param } from '@nestjs/common';

//(...)

@Get(':id')
async
getTodoById(@Param('id', ParseIntPipe)
id: number
)
{
  await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate async operation

  const todo = this.todos.find((todo) => todo.id === id);
  if (!todo) {
    throw new Error('Todo not found');
  }
  return todo;
}
```

Explication du code:

- `@Get(':id')`: Le décorateur `@Get(':id')` indique que cette méthode sera appelée pour les requêtes HTTP GET à l'URL
  `/todo/:id`, où `:id` est un paramètre d'URL.
- `async getTodoById(@Param('id', ParseIntPipe) id: number)`: La méthode `getTodoById` est définie comme asynchrone et
  utilise le décorateur `@Param('id', ParseIntPipe)` pour extraire le paramètre `id` de l'URL. Le `ParseIntPipe`
  convertit automatiquement le paramètre en un nombre entier.
- `await new Promise((resolve) => setTimeout(resolve, 1000))`: Comme précédemment, cette ligne simule une opération
  asynchrone.
- `const todo = this.todos.find((todo) => todo.id === id)`: Nous recherchons la tâche avec l'ID spécifié dans le tableau
  `todos`.
- `if (!todo) { throw new Error('Todo not found'); }`: Si la tâche n'est pas trouvée, nous lançons une erreur. Dans un
  cas réel, vous pourriez utiliser un `NotFoundException` de NestJS pour renvoyer une réponse HTTP 404.
- `return todo`: Si la tâche est trouvée, nous la renvoyons. NestJS convertit automatiquement l'objet en JSON pour la
  réponse HTTP.
- Notez que dans un cas réel, vous devriez gérer les erreurs de manière appropriée en utilisant des exceptions
  spécifiques de NestJS, comme `NotFoundException`, pour renvoyer des réponses HTTP correctes. (on le verra plus tard)

### Put

Pour ajouter un endpoint PUT qui permet de mettre à jour une tâche existante, nous allons utiliser le décorateur
`@Put(':id')`. Nous
allons également utiliser le décorateur `@Body()` pour extraire les données de la requête.

```typescript
import { Controller, Get, Post, Body, Param, Put } from '@nestjs/common';

//(...)

@Put(':id')
async
updateTodo(@Param('id', ParseIntPipe)
id: number, @Body()
body: any
)
{
  await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate async operation

  const existingTodo = this.todos.find((todo) => todo.id === id);
  if (!existingTodo) {
    throw new Error('Todo not found');
  }

  existingTodo.title = body.title || existingTodo.title;

  return existingTodo;
}
```

Explication du code:

- `@Put(':id')`: Le décorateur `@Put(':id')` indique que cette méthode sera appelée pour les requêtes HTTP PUT à l'URL
  `/todo/:id`, où `:id` est un paramètre d'URL.
- `async updateTodo(@Param('id', ParseIntPipe) id: number, @Body() body: any)`: La méthode `updateTodo` est définie
  comme asynchrone et utilise le décorateur `@Param('id', ParseIntPipe)` pour extraire le paramètre `id` de l'URL, ainsi
  que le décorateur `@Body()` pour extraire les données de la requête.
- `await new Promise((resolve) => setTimeout(resolve, 1000))`: Comme précédemment, cette ligne simule une opération
  asynchrone.
- `const existingTodo = this.todos.find((todo) => todo.id === id)`: Nous recherchons la tâche avec l'ID spécifié dans le
  tableau `todos`.
- `if (!existingTodo) { throw new Error('Todo not found'); }`: Si la tâche n'est pas trouvée, nous lançons une erreur.
  Dans un cas réel, vous pourriez utiliser un `NotFoundException` de NestJS pour renvoyer une réponse HTTP 404.
- `existingTodo.title = body.title || existingTodo.title`: Nous mettons à jour le titre de la tâche avec la valeur
  fournie dans le corps de la requête, ou conservons l'ancien titre si aucune valeur n'est fournie.
- `return existingTodo`: La méthode renvoie la tâche mise à jour. NestJS convertit automatiquement l'objet en JSON pour
  la réponse HTTP.
- Notez que dans un cas réel, vous devriez gérer les erreurs de manière appropriée en utilisant des exceptions
  spécifiques de NestJS, comme `NotFoundException`, pour renvoyer des réponses HTTP correctes. (on le verra plus tard)

### Patch

Pour ajouter un endpoint PATCH qui permet de mettre à jour partiellement une tâche existante, nous allons utiliser le
décorateur
`@Patch(':id')`. Nous allons également utiliser le décorateur `@Body()` pour extraire les données de la requête.

```typescript
import { Controller, Get, Post, Body, Param, Put, Patch } from '@nestjs/common';

//(...)

@Patch(':id/complete')
async
toggleTodoCompletion(@Param('id', ParseIntPipe)
id: number, @Body()
body: any
)
{
  await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate async operation

  const todo = this.todos.find((todo) => todo.id === id);
  if (!todo) {
    throw new Error('Todo not found');
  }

  todo.completed = body.completed != undefined ? body.completed : !todo.completed;

  return todo;
}
```

Explication du code:

- `@Patch(':id/complete')`: Le décorateur `@Patch(':id/complete')` indique que cette méthode sera appelée pour les
  requêtes HTTP PATCH à l'URL `/todo/:id/complete`, où `:id` est un paramètre d'URL.
- `async toggleTodoCompletion(@Param('id', ParseIntPipe) id: number, @Body() body: any)`: La méthode
  `toggleTodoCompletion` est définie comme asynchrone et utilise le décorateur `@Param('id', ParseIntPipe)` pour
  extraire le paramètre `id` de l'URL, ainsi que le décorateur `@Body()` pour extraire les données de la requête.
- `await new Promise((resolve) => setTimeout(resolve, 1000))`: Comme précédemment, cette ligne simule une opération
  asynchrone.
- `const todo = this.todos.find((todo) => todo.id === id)`: Nous recherchons la tâche avec l'ID spécifié dans le tableau
  `todos`.
- `if (!todo) { throw new Error('Todo not found'); }`: Si la tâche n'est pas trouvée, nous lançons une erreur. Dans un
  cas réel, vous pourriez utiliser un `NotFoundException` de NestJS pour renvoyer une réponse HTTP 404.
- `todo.completed = body.completed != undefined ? body.completed : !todo.completed`: Nous mettons à jour l'état de la
  tâche en fonction de la valeur fournie dans le corps de la requête. Si `body.completed` est défini, nous l'utilisons ;
  sinon, nous basculons l'état actuel de la tâche.
- `return todo`: La méthode renvoie la tâche mise à jour. NestJS convertit automatiquement l'objet en JSON pour la
  réponse HTTP.
- Notez que dans un cas réel, vous devriez gérer les erreurs de manière appropriée en utilisant des exceptions
  spécifiques de NestJS, comme `NotFoundException`, pour renvoyer des réponses HTTP correctes. (on le verra plus tard)

### Delete

Pour ajouter un endpoint DELETE qui permet de supprimer une tâche existante, nous allons utiliser le décorateur
`@Delete(':id')`. Nous allons également utiliser le décorateur `@Param()` pour extraire le paramètre d'URL.

```typescript
import { Controller, Get, Post, Body, Param, Put, Patch, Delete } from '@nestjs/common';
//(...)
@Delete(':id')
async
deleteTodo(@Param('id', ParseIntPipe)
id: number
)
{
  await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate async operation

  const index = this.todos.findIndex((todo) => todo.id === id);
  if (index === -1) {
    throw new Error('Todo not found');
  }

  const deletedTodo = this.todos.splice(index, 1);
  return deletedTodo[0];
}
```

Explication du code:

- `@Delete(':id')`: Le décorateur `@Delete(':id')` indique que cette méthode sera appelée pour les requêtes HTTP DELETE
  à l'URL `/todo/:id`, où `:id` est un paramètre d'URL.
- `async deleteTodo(@Param('id', ParseIntPipe) id: number)`: La méthode `deleteTodo` est définie comme asynchrone et
  utilise le décorateur `@Param('id', ParseIntPipe)` pour extraire le paramètre `id` de l'URL.
- `await new Promise((resolve) => setTimeout(resolve, 1000))`: Comme précédemment, cette ligne simule une
  opération asynchrone.
- `const index = this.todos.findIndex((todo) => todo.id === id)`: Nous recherchons l'index de la tâche avec l'ID
  spécifié dans le tableau `todos`.
- `if (index === -1) { throw new Error('Todo not found'); }`: Si la tâche n'est pas trouvée, nous lançons une
  erreur. Dans un cas réel, vous pourriez utiliser un `NotFoundException` de NestJS pour renvoyer une réponse HTTP 404.
- `const deletedTodo = this.todos.splice(index, 1)`: Nous supprimons la tâche du tableau `todos` en utilisant
  la méthode `splice`, qui modifie le tableau en place et renvoie un tableau contenant les éléments supprimés.
- `return deletedTodo[0]`: La méthode renvoie la tâche supprimée. NestJS convertit automatiquement l'objet en JSON
  pour la réponse HTTP.
- Notez que dans un cas réel, vous devriez gérer les erreurs de manière appropriée en utilisant des exceptions
  spécifiques de NestJS, comme `NotFoundException`, pour renvoyer des réponses HTTP correctes. (on le verra plus tard)
