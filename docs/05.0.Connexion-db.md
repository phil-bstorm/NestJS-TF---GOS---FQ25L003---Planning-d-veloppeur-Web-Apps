# Connexion √† la base de donn√©es avec TypeORM

TypeORM est un ORM (Object-Relational Mapping) qui permet de g√©rer la connexion √† la base de donn√©es et les entit√©s de
mani√®re efficace. Dans ce chapitre, nous allons configurer TypeORM pour se connecter √† une base de donn√©es MSSQL et
d√©finir les entit√©s User et Todo.

## Installation de TypeORM et des d√©pendances

Pour commencer, nous devons installer TypeORM ainsi que le pilote MSSQL. Ex√©cutez la commande suivante dans votre
projet NestJS :

```bash
npm install @nestjs/typeorm typeorm mssql
```

- `@nestjs/typeorm` : Le module TypeORM pour NestJS.
- `typeorm` : Le package principal de TypeORM.
- `mssql` : Le pilote pour se connecter √† une base de donn√©es MSSQL.

## Configuration de TypeORM

Dans le fichier `app.module.ts`, nous allons configurer TypeORM pour se connecter √† notre base de donn√©es MSSQL. Voici
un exemple de configuration :

```typescript
import { Module } from '@nestjs/common';
import { AppController } from './controllers/app.controller';
import { AppService } from './app.service';
import { TodoController } from './controllers/todo.controller';
import { TodoService } from './services/todo.service';
import { TypeOrmModule } from '@nestjs/typeorm';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'mssql',
      host: 'localhost',
      port: 1433,
      database: 'nestjs_todo',
      username: 'SA',
      password: 'Some4Complex#Password',
      options: {
        encrypt: true, // Use true if you're using Azure SQL
        trustServerCertificate: true, // Use true for local development
      },
      synchronize: true,
      logging: true,
      entities: [
        // TODO enregistrement des entit√©s ici
      ],
    }),
    TypeOrmModule.forFeature([
      // TODO enregistrement des entit√©s ici
    ]),
  ],
  controllers: [AppController, TodoController],
  providers: [AppService, TodoService],
})
export class AppModule {}
```

Dans cette configuration :

- `type` : Le type de base de donn√©es, ici `mssql`.
- `host` : L'adresse du serveur de base de donn√©es.
- `port` : Le port sur lequel le serveur de base de donn√©es √©coute, par d√©faut 1433 pour MSSQL.
- `database` : Le nom de la base de donn√©es √† laquelle se connecter.
- `username` et `password` : Les identifiants pour se connecter √† la base de donn√©es.
- `options` : Options suppl√©mentaires pour la connexion, comme `encrypt` pour les connexions s√©curis√©es et
  `trustServerCertificate` pour les environnements de d√©veloppement locaux.
- `synchronize` : Si `true`, TypeORM synchronisera automatiquement les entit√©s avec la base de donn√©es √† chaque
  d√©marrage de l'application. **Attention** : Ne pas utiliser en production, car cela peut entra√Æner la perte de
  donn√©es.
- `logging` : Si `true`, TypeORM affichera les requ√™tes SQL dans la console.
- `entities` : Liste des entit√©s √† enregistrer. Nous allons ajouter les entit√©s `User` et `Todo` ici.
- `TypeOrmModule.forFeature` : Permet d'enregistrer les entit√©s pour l'injection de d√©pendances dans les services.

## D√©finition des entit√©s

### Entit√© Todo

Cr√©ons d'abord l'entit√© `Todo`. Cr√©ez un fichier `todo.entity.ts` dans le dossier `entities` :

```typescript
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity({ name: 'todo' })
export class TodoEntity {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ length: 100 })
  title: string;

  @Column({ type: 'text', nullable: true })
  description: string | null;

  @Column({ default: false })
  completed: boolean;
}
```

Expliquons les annotations utilis√©es :

- `@Entity()` : Indique que cette classe est une entit√© de base de donn√©es.
  - `{name: 'todo'}` : Sp√©cifie le nom de la table dans la base de donn√©es.
- `@PrimaryGeneratedColumn()` : Indique que cette colonne est une cl√© primaire g√©n√©r√©e automatiquement.
- `@Column()` : Indique une colonne de la table. Les options comme `length`, `type`, et `nullable` permettent de d√©finir
  les propri√©t√©s de la colonne.
- `@Column({ default: false })` : D√©finit une valeur par d√©faut pour la colonne `completed`.
- `nullable: true` : Indique que la colonne peut √™tre nulle.
- `type: 'text'` : D√©finit le type de la colonne comme texte, utile pour des descriptions longues.
- `length: 100` : D√©finit la longueur maximale de la colonne `title`.

üîé Si `{ name: 'todo' }` n'√©tait pas pr√©sent, le nom de la table en DB serait : ```todo_entity`.

## Ajout de l'entit√© Todo dans le module TypeORM

Ajoutons maintenant l'entit√© `Todo` dans le module TypeORM. Modifiez le fichier `app.module.ts` pour inclure l'entit√©
`Todo` :

```typescript
//(...)
imports: [
  TypeOrmModule.forRoot({
    type: 'mssql',
    host: 'localhost',
    port: 1433,
    database: 'nestjs_todo',
    username: 'SA',
    password: 'Some4Complex#Password',
    options: {
      encrypt: true,
      trustServerCertificate: true,
    },
    synchronize: true,
    logging: true,
    entities: [TodoEntity], // Enregistrement de l'entit√© TodoEntity
  }),
  TypeOrmModule.forFeature([TodoEntity]), // Enregistrement de l'entit√© TodoEntity
],
//(...)
```

## Mise √† jour du service pour utiliser la base de donn√©es

Dans le service, nous allons utiliser uniquement les **entit√©s**, pas les DTOs. Voici un exemple de service `TodoService` :

```typescript
import { Body, Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { TodoEntity } from 'src/entities/todo.entity';
import { Repository } from 'typeorm';

@Injectable()
export class TodoService {
  constructor(
    @InjectRepository(TodoEntity)
    private readonly todoRepository: Repository<TodoEntity>,
  ) {}

  async getAll() {
    return this.todoRepository.find();
  }

  async create(body: TodoEntity) {
    return this.todoRepository.save(body);
  }

  async getById(id: number) {
    const todo = await this.todoRepository.findOne({ where: { id } });
    if (!todo) {
      throw new Error('Todo not found');
    }
    return todo;
  }

  async update(body: TodoEntity) {
    return await this.todoRepository.save(body);
  }

  async delete(id: number) {
    const existingTodo = await this.todoRepository.findOne({ where: { id } });
    if (!existingTodo) {
      throw new Error('Todo not found');
    }

    await this.todoRepository.remove(existingTodo);
    return existingTodo;
  }

  async toggleTodoCompletion(body: TodoEntity) {
    return await this.todoRepository.save(body);
  }
}
```

üîé On note que toute la logique fusion d'objet (qui se faisait avant dans le service) ne se fait plus dans le service mais se fera dans un `mapper` (prochain chapitre).
