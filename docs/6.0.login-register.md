# Login et register

Avant de continuer, vers les middlewares, il faut cr√©er un contr√¥leur pour g√©rer les actions de connexion et
d'inscription des utilisateurs.

## D√©pendance pour l'encryptage des mots de passe

- Installer le package `bcrypt` pour le hachage des mots de passe :

```bash
npm install bcrypt
npm i @types/bcrypt -D
```

## Cr√©ation de l'entity `UserEntity`

```typescript
import { UserRole } from 'src/shared/enums/user-role.enum';
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity({ name: 'user' })
export class UserEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ length: 100, unique: true })
  username: string;

  @Column()
  password: string;

  @Column()
  firstname: string;

  @Column({ default: UserRole.Client })
  role: UserRole;
}
```

üîé Le role est g√©n√©r√© avec une √©num√©ration nomm√©e `UserRole`:
_(src/shared/enums/user-role.enum.ts)_

```typescript
export enum UserRole {
  Admin = 'admin',
  Manager = 'manager',
  Client = 'client',
}
```

‚ö†Ô∏è Ne pas oubli√© d'importer `UserEntity` dans le `app.module.ts` dans le module de TypeORM.

## Cr√©ation du service `UserService`

- Cr√©er le `user.service.ts` dans le dossier `src/services` :

```bash
nest g s services/user
```

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { UserEntity } from 'src/entities/user.entity';
import { Repository } from 'typeorm';
import * as bcrypt from 'bcrypt';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(UserEntity)
    private readonly userRepository: Repository<UserEntity>,
  ) {}

  async create(newUser: UserEntity) {
    const existingUsername = await this.userRepository.findOne({
      where: {
        username: newUser.username.toLowerCase(),
      },
    });

    if (existingUsername) {
      throw new Error('Username already exists');
    }

    newUser.password = await bcrypt.hash(newUser.password, 10);

    return this.userRepository.save(newUser);
  }

  async login(username: string, password: string) {
    const existingUsername = await this.userRepository.findOne({
      where: {
        username: username.toLowerCase(),
      },
    });

    if (!existingUsername) {
      throw new Error('Invalid login');
    }

    const isValidPassword = await bcrypt.compare(password, existingUsername.password);
    if (!isValidPassword) {
      throw new Error('Invalid login');
    }

    return existingUsername;
  }
}
```

## Cr√©ation des DTOs

- Cr√©er le fichier `src\dtos\auth.form.dto.ts` :

```typescript
import { IsString } from 'class-validator';

export class AuthRegisterFormDto {
  @IsString()
  username: string;

  @IsString()
  password: string;
}

export class AuthLoginFormDto {
  @IsString()
  username: string;

  @IsString()
  password: string;
}
```

## Cr√©ation des mappers

- Cr√©er le fichier `src\mappers\user.mappers.ts`:

```typescript
import { AuthRegisterFormDto } from 'src/dtos/auth.form.dto';
import { UserEntity } from 'src/entities/user.entity';

// DTO -> Entity
export function authRegisterFormDtoToUserEntity(dto: AuthRegisterFormDto): UserEntity {
  const user = new UserEntity();
  user.username = dto.username.toLowerCase();
  user.password = dto.password;

  return user;
}

// Entity -> DTO
// actuellement non n√©cessaire car non demand√© dans l'application
```

üîé Il n'est pas n√©cessaire de faire un mapper pour `AuthLoginFormDto` car il y a peu de chance que l'on utilise plus que `username` et `password` pour l'authentification.

## Cr√©ation du auth controller

- Cr√©er le `auth.controller.ts` dans le dossier `src/controllers` :

```bash
nest g co controllers/auth
```

```typescript
import { Body, Controller, Post } from '@nestjs/common';
import { UserService } from '../services/auth.service';
import { AuthRegisterFormDto, AuthLoginFormDto } from '../dtos/auth.form.dto';
import { AuthRegisterFormDtoToEntity } from '../mappers/auth.mappers';

@Controller('auth')
export class AuthController {
  constructor(private readonly UserService: UserService) {}

  @Post('register')
  async register(@Body() body: AuthRegisterFormDto) {
    const userEntity = AuthRegisterFormDtoToEntity(body);
    await this.UserService.register(userEntity);
    // No return value, just a success response
    return;
  }

  @Post('login')
  async login(@Body() body: AuthLoginFormDto) {
    const user = await this.UserService.login(body.username, body.password);

    // TODO - impl√©menter la logique de g√©n√©ration de token JWT
    return { token: 'TODO un token!' + user.username };
  }
}
```

## G√©n√©ration du token JWT

### D√©pendances

Pour g√©n√©rer un token JWT lors de la connexion, nous allons utiliser le package `@nestjs/jwt`.

- Installer le package `@nestjs/jwt` et `@nestjs/config` :

```bash
npm install @nestjs/jwt @nestjs/config
```

- `@nestjs/jwt` : Fournit des fonctionnalit√©s pour travailler avec JSON Web Tokens (JWT) dans NestJS.
- `@nestjs/config` : Permet de g√©rer la configuration de l'application, y compris les variables d'environnement.

### Configuration de l'environnement

- Cr√©er un fichier `.env.dev` √† la racine du projet avec le contenu suivant :

```plaintext
NODE_ENV=development
JWT_SECRET="gB2m7==ptkXoH0BD8(<j'?Yrrom%)yrvNLf9oAw#!g=u_qL|wS"
```

üîé il est aussi recommand√© de d√©placer les informations de connexion √† la base de donn√©e dans ce fichier et d'utliser `process.env` pour r√©cup√©rer les diff√©rentes variables d'environnement.

Dans app.module.ts, ajouter les imports de `ConfigModule` et `JwtModule` dans le tableau `imports` :

```typescript
// (...)

@Module({
  imports: [
    ConfigModule.forRoot({ envFilePath: ['.env.dev', '.env'] }),
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '1d' },
    }),
//(...)
```

- `ConfigModule.forRoot()` : Charge les variables d'environnement √† partir des fichiers `.env`.
- `JwtModule.register()` : Configure le module JWT avec le secret et les options de signature. Le secret est r√©cup√©r√© √†
  partir des variables d'environnement, et le token expirera apr√®s 1 jour (`expiresIn: '1d'`).

### G√©n√©ration du token JWT dans le controller

Dans le `auth.controller.ts`, nous allons injecter le `JwtService` et l'utiliser pour g√©n√©rer un token lors de la
connexion de l'utilisateur.

```typescript
    @Post('login')
    async login(@Body() body: AuthLoginFormDto) {
    const user = await this.userService.login(body.username, body.password);

    // on stock l'id et le role de l'utilisateur dans le token
    const token = this.jwtService.sign({
      id: user.id,
      role: user.role,
    });

    return { token };
  }
```
