# Guard avec tags

Les guards en NestJS peuvent être utilisés avec des tags(décorateurs) pour appliquer des règles d'accès spécifiques à certaines
routes ou contrôleurs. Cela permet de gérer les autorisations de manière plus granulaire.

## Création d'un guard qui utilise des décorateurs

1. Créez le décorateur que l'on va utiliser pour marquer les routes nécessitant une vérification spécifique. Par exemple, un décorateur
   `@RequireRoles` pour spécifier les rôles requis pour accéder à une route.
2. Créez un guard qui utilise ce décorateur pour vérifier si l'utilisateur a les rôles requis.
3. Appliquez le décorateur et le guard aux routes ou contrôleurs que vous souhaitez protéger.

Pour garder une structure claire, nous allons créer un dossier `require-roles` dans le dossier `guards` pour y placer notre décorateur et notre guard.

### Étape 1 : Création du décorateur `@RequireRoles`

Créez un fichier `require-roles.decorator.ts` dans le dossier `guards/RequireRoles` :

```bash
nest g decorator guards/require-roles/require-roles
```

```typescript
import { SetMetadata } from '@nestjs/common';
import { UserRole } from '../../shared/enums/user-role.enum';

export const RequireRoles = (...roles: UserRole[]) => SetMetadata('require-roles', roles);
```

Explication :

- `SetMetadata`: Fonction qui permet de définir des métadonnées sur une route ou un contrôleur.
- `UserRole`: Enum qui représente les rôles d'utilisateur
- `RequireRoles`: Décorateur qui prend un ou plusieurs rôles et les enregistre comme métadonnées sous la clé `'require-roles'`.
- Ce décorateur peut être utilisé pour marquer les routes qui nécessitent des rôles spécifiques pour y accéder.

### Étape 2 : Création du guard `RequireRolesGuard`

Créez un fichier `require-roles.guard.ts` dans le dossier `guards/RequireRoles` :

```bash
nest g guard guards/require-roles/require-roles
```

```typescript
import { CanActivate, ExecutionContext, ForbiddenException, Injectable } from '@nestjs/common';
import { Observable } from 'rxjs';
import { Reflector } from '@nestjs/core';
import { Request } from 'express';
import { Session } from '../../shared/interfaces/session.interface';

@Injectable()
export class RequireRolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    const requiredRoles = this.reflector.get<string[]>('require_roles', context.getHandler());
    const req: Request & { session: Session } = context.switchToHttp().getRequest();

    const userRole = req.session?.role;

    if (!requiredRoles.some((role) => role === userRole)) {
      throw new ForbiddenException(
        'You must have at least one role :' + requiredRoles.join(' or '),
      );
    }

    return true;
  }
}
```

Explication :

- `CanActivate`: Interface que le guard doit implémenter pour être utilisé comme un guard.
- `ExecutionContext`: Contexte d'exécution qui contient des informations sur la requête en cours.
- `Reflector`: Service qui permet de récupérer les métadonnées définies par les décorateurs.
- `Request`: Interface de la requête HTTP, étendue pour inclure la session.
- `Session`: Interface qui représente la session de l'utilisateur, contenant des informations comme le rôle.
- `RequireRolesGuard`: Guard qui vérifie si l'utilisateur a au moins un des rôles requis pour accéder à la route.

### Étape 3 : Application du décorateur et du guard

Pour utiliser le décorateur et le guard, vous devez les appliquer à vos routes ou contrôleurs ou modules.

Exemple sur une route `Get` du `TodoController` :

```typescript
@Get()
@UseGuards(RequireRolesGuard) // NEW
@RequireRoles(UserRole.Client) // NEW
async getTodos(): Promise<TodoDto[]> {
   const todos = await this.todoService.getTodos();
   return todos.map(todoEntityToDto);
}
```
