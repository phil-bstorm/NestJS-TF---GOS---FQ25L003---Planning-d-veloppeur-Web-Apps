# Guard avec tags

Les guards en NestJS peuvent être utilisés avec des tags(décorateurs) pour appliquer des règles d'accès spécifiques à certaines
routes ou contrôleurs. Cela permet de gérer les autorisations de manière plus granulaire.

## Création d'un guard qui utilise des décorateurs

1. Créez le décorateur que l'on va utiliser pour marquer les routes nécessitant une vérification spécifique. Par exemple, un décorateur
   `@RequireRoles` pour spécifier les rôles requis pour accéder à une route.
2. Créez un guard qui utilise ce décorateur pour vérifier si l'utilisateur a les rôles requis.
3. Appliquez le décorateur et le guard aux routes ou contrôleurs que vous souhaitez protéger.

Pour garder une structure claire, nous allons créer un dossier `require-roles` dans le dossier `guards` pour y placer notre décorateur et notre guard.

### Étape 1 : Création du décorateur `@RequireRoles`

Créez un fichier `require-roles.decorator.ts` dans le dossier `guards/RequireRoles` :

```bash
nest g decorator guards/require-roles/require-roles
```

```typescript
import { SetMetadata } from '@nestjs/common';
import { UserRole } from 'src/shared/enums/user-role.enum';

export const RequireRoles = (...args: UserRole[]) => SetMetadata('require-roles', args);
```

Explication :

- `SetMetadata`: Fonction qui permet de définir des métadonnées sur une route ou un contrôleur.
- `UserRole`: Enum qui représente les rôles d'utilisateur
- `RequireRoles`: Décorateur qui prend un ou plusieurs rôles et les enregistre comme métadonnées sous la clé `'require-roles'`.
- Ce décorateur peut être utilisé pour marquer les routes qui nécessitent des rôles spécifiques pour y accéder.

### Étape 2 : Création du guard `RequireRolesGuard`

Créez un fichier `require-roles.guard.ts` dans le dossier `guards/RequireRoles` :

```bash
nest g guard guards/require-roles/require-roles
```

```typescript
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';
import { UserRole } from 'src/shared/enums/user-role.enum';
import { Session } from 'src/shared/interfaces/session.interface';

@Injectable()
export class RequireRolesGuard implements CanActivate {
  constructor(private readonly reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    // Récupere le décorateur @RequireRoles et ses parametres
    const roles = this.reflector.get<UserRole[]>('require-roles', context.getHandler());

    // Récupere la requete (avec la session)
    const request: Request & { session: Session } = context.switchToHttp().getRequest();
    const session = request.session;

    if (!session) {
      // Si l'utilisateur n'est pas connecté (pas de session), on refuse l'accès
      return false;
    }

    return roles.includes(session.role);
  }
}
```

Explication :

- `CanActivate`: Interface que le guard doit implémenter pour être utilisé comme un guard.
- `ExecutionContext`: Contexte d'exécution qui contient des informations sur la requête en cours.
- `Reflector`: Service qui permet de récupérer les métadonnées définies par les décorateurs.
- `Request`: Interface de la requête HTTP, étendue pour inclure la session.
- `Session`: Interface qui représente la session de l'utilisateur, contenant des informations comme le rôle.
- `RequireRolesGuard`: Guard qui vérifie si l'utilisateur a au moins un des rôles requis pour accéder à la route.

### Étape 3 : Application du décorateur et du guard

Pour utiliser le décorateur et le guard, vous devez les appliquer à vos routes ou contrôleurs ou modules.

Exemple sur une route `create` du `TodoController` :

```typescript
  @Post()
  @RequireRoles(UserRole.Admin, UserRole.Manager) // Mentionne les rôles requis pour accéder à cette route
  @UseGuards(RequireRolesGuard) // Applique le guard pour vérifier les rôles
  async create(@Body() body: TodoCreateFormDto) {
    const entity = todoFormDtoToEntity(body);
    const newEntity = await this.todoService.create(entity);
    return todoEntityToTodoDto(newEntity);
  }
```
